3.1

Long term scheduling(Job scheduler)

하드 디스크에서 메모리로 프로세스를 load하는 역할을 한다

short-term scheduling(CPU scheduler)

메모리에 있는 프로세스 중에서 프로세스가 CPU 점유권을 가질 때,
어떤 프로세스가 선택되는지를 결정하는 스케줄러이다.

Medium-term scheduling
프로세스가 running 으로 넘어가지 못할 때 메모리 차지해서 비효율적인 상황이
발생한다. 그래서 메모리에 있던 프로세스를 하드디스크에 적재한다.
나중에 필요할 때 하드 디스크에 있는 프로세스를 메모리에 보관한다

3.2
인터럽트를 통해 문맥 교환이 일어나면 커널은 현재 실행하던 
프로세스의 CPU레지스터의 값, 
메모리 관리 정보등을 PCB에 저장하고 프로세스 상태를 변경 한다. 
이전 프로세스의 PCB는 대기큐에 등록이 된다. 
새로운 프로세스의전 내용을 복귀하고 
새로운 프로세스가 실행된다.

3.3

3.4
부팅시 init 프로세스는 부트스트랩에 실행되는 최초 프로세스다. 
이 후 모든 프로세스는 init가 조상 프로세스가 된다. 
init는 프로세스는 운영체제 구동을 위한 모든 프로세스는 차례대로 호출한다. 
부팅이 완료되면 init 프로세스는 다른 프로세스를 감시하며 
좀비 프로세스가 된 프로세스의 리소스를 해제한다.

3.5
2^4 process

3.6
그림 3.32에서 printf(“LINE J”)는 execlp명령어 뒤에 위치하고 있는데 
exec계열의 명령어는 해당 명령의 파라메터로 전달되는 
다른 명령을 실행하여 주고 자신은 사라진다. 
따라서 정상적인 경우에는 결과에서 “LINE J”를 볼 수가 없다. 
하지만 execlp의 파라메터가 잘못 되었거나
(해당 명령어가 존재하지 않거나 명령어의 위치를 잘못 지정한 경우 등) 
지정된 프로그램이 존재하지 않는 경우에 
execlp명령이 실패하고 다음 줄인 “LINE J”가 출력될 수 있다.

3.7

3.8
파이프는 프로세스간의 통신을 위한 일종의 채널이다. 
일반 파이프는 파이프를 사용하는 프로세스가 실행 중일때만 존재한다. 
따라서 일반 파이프는 특정 프로세스만 파이프를 이용할 때 유용하다. 
반대로 지명 파이프는 파일 시스템을 사용하여 
프로세스간의 통신을 구현하는 기법으로써 
특정한 속성을 갖는 파이프를 다수의 프로세스에서 이용하고자 할 때 유용하다.

3.9
a. 동기적 통신과 비동기적 통신: 
동기적 통신은 메시지를 보내고 답변이 올 때까지 해당 답변을 기다리는 방식으로 
시스템 관점과 프로그래머 관점에서 구현이 간단하다는 장점이 있지만, 
답변이 올 때가지 프로세스가 어떠한 작업도 할 수 없다는 단점이 존재한다. 반대로 비동기적 통신은 이벤트 핸들러를 이용해야 하는 등의 오버헤드가 발생하지만, 통신을 하면서 프로세스가 다른 작업을 수행할 수 있다는 장점이 있다.

b. 자동과 명시적 버퍼링
자동 버퍼링의 경우에는 운영체제가 판단하기에 
버퍼링이 필요한 경우에 버퍼링을 수행하기 때문에 
시스템 관점에서는 효율적인 자원 활용이 장점이고 
프로그래머의 관점에서는 프로그램 구현이 단순해진다는 장점이 존재한다. 
그러나 어떠한 경우에는 
프로그래머가 명시적으로 정의한 버퍼링보다 효율이 안 좋을 수도 있다. 
반대로 명시적 버퍼링의 경우에는 프로그래머가 명시적으로 
버퍼링을 수행하도록 구현해야하는 단점이 존재하지만 튜닝을 잘 하면 
자동 버퍼링보다 높은 성능 향상을 기대할 수 있다.


c. 복사에 의한 송신과 참조에 의한 송신
복사에 의한 송신은 원본 데이터는 
그대로 유지하기 때문에 데이터의 안정성을 확보할 수 있지만, 
데이터의 복사 과정에서 오버헤드가 발생하는 단점이 존재한다. 
참조에 의한 송신은 데이터의 복사 과정이 없기 때문에 
오버헤드가 발생하지 않는 장점이 존재하지만, 
다른 함수나 객체에서 의도하지않게 원본 데이터의 값을 변경하게되는 
side effect가 발생할 수도 있다.


d. 고정 크기와 가변 크기 메시지
고정 크기 메시지는 
시스템 관점에서 항상 고정된 크기의 메시지를 다루기 때문에 파이프라이닝, 
버퍼링 등 시스템의 효율을 향상시킬 수 있는 기법을 활용할 수 있다는 
장점이 존재하며, 프로그래머의 관점에서는 구현이 쉽다는 장점이 있다. 
그러나 고정 크기 메시지는 설정된 크기보다 작은 크기의 메시지는 공간 낭비를, 
설정된 크기보다 큰 메시지는 전송이 불가능하다는 단점이 존재한다. 
반대로 가변 크기 메시지는 
시스템이 연산을 최적화할 수 없다는 단점과 
구현이 복잡해지는 단점이 존재하지만 
공간을 효율적으로 활용할 수 있고, 
메모리의 범위 안에서 모든 크기의 메시지를 전송할 수 있다는 장점이 존재한다.



